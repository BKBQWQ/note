## 壳的认识
1. 壳就是给文件穿上了一件衣服，使你看不见他原本的样子，其实程序在计算机上实际上就是一段 **二进制数据** ，而壳就是对这段 **二进制数据** 进行了加密操作，在学习PE文件时可以对可执行程序有更深的了解这里不过多介绍。但是加壳后的程序本身的运行却不受影响，是因为在执行真正的程序前会执行一段"解壳"的代码，来恢复原本的程序，手动脱壳就是要将"解壳"后的 **真实程序dump** 下来为己所用。
2. 从上面看来，壳似乎对动态调试程序影响不大，因为无论是否加壳程序依旧可以运行，所以壳大部分只会对静态分析程序的原本代码造成印象。

## 工具脱壳
1. 其实关于许多常见的壳,例如upx壳已已经有现成的工具来脱壳，但是对于一些加密壳，修改壳和目前没有脱壳工具的壳，就必须手动脱壳了。
## 手动脱壳的原理
1. 手动脱壳的而原理，依赖于壳在执行前会将主程序所用到的寄存器(ax,bx,cx)等，会压栈(pushab)保存，在壳执行完成后再出栈(popab)。
2. 手动脱壳的目的就是，就是在执行完"壳程序"后，找到正真程序并将其保存(dump)。
3. 在实行程序前，壳程序会优先获得程序的控制，将程序恢复并加载进入内存。
## 实际操作
1. 例题为：[[HZNUCTF 2023 final]signin](https://www.nssctf.cn/problem/3597)，只就手动脱壳进行操作，不关心题目本身！
2. 工具为x64dbg/x32dbg，大家壳自行下载。
3.  首先将程序拖入x64dbg，中。![](https://img-blog.csdnimg.cn/direct/7683373a0e0f4b96a0f9046961f2235c.png#pic_center)
4. 单步F8步过，或者直接F9，找到pushab指令，如果没有Pushab指令，则继续单步调试，直到仅有 **Esp寄存器爆红** (证明可以使用栈平衡脱壳)：![](https://img-blog.csdnimg.cn/direct/8f079981607544ed8ba917950873e979.png#pic_center)![](https://img-blog.csdnimg.cn/direct/3008018cc59f41ef8e0d2a1fbe3aef08.png#pic_center)
5. 此时，寄存器的值已经入栈，通过观察 **栈的窗口** 或 **内存窗口** 两者均显示了压栈的寄存器的值，可以看见，ax,bx,cx,dx寄存器的值均一入栈：![](https://img-blog.csdnimg.cn/direct/0ea0c4d64f084307a35c213c0e2e787a.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c3cd187bb1a24d8094ca1fbb67f6be8a.png#pic_center)
6. 此时在栈上地址为006ff908处(此处保存了寄存器ax的值)打上硬件访问断点(1，2，4字节无所谓)，这样在壳程序执行完成后 **寄存器出栈**时会自动暂停，一定时硬件访问断点(级别比写入断点更高，只要 **访问** 这个内存位置就会停下来)。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a84220125c4f48d98029f45f55c95505.png#pic_center)
7. 接下来，直接F9到刚才打的断点处，可以惊喜的发现，梦寐以求的pushab指令正在此处：![](https://img-blog.csdnimg.cn/direct/b4b124e4312c426b997903be332a187e.png#pic_center)
8. 此时，实际上已经脱壳完毕，但是一直单步步过会发现，一直在一个向上跳转的循环里，观察这股循环可以发现循环的作用是一直在压栈，并与ax寄存器里的值进行比较，直到相同才退出，push的值一直是0，推测这个循环的作用是**将堆栈中的值清零**，这样也解释了前面在进入壳程序时为什么要进行压栈操作，ax其保存了壳程序使用的栈空间(栈低相差80*2个字节)，在退出壳程序后需要清空。在跳转指令后面打上断点后F9即可跳出循环。
9. 到jmp指令这里可以发现esp栈指针已近已经到了进入壳程序前的位置。
10. 插件栏，使用Scylla插件(先清楚掉之前打的断点)，将文件dump下来：![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a6ddae5affbb4e11873888cd3cb8a6fb.png#pic_center)
11. 脱壳完成直接拉入ida进行静态分析，此时ida可以进行静态分析，虽然程序无法执行：![](https://img-blog.csdnimg.cn/direct/4e06ac89a31e4eb986727598effe1d1f.png#pic_center)
12. 脱壳前拉入ida时并没有这么多函数，ida无法反汇编分析：![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5f8c15cb0abc442f9b8b048cd09fc2d2.png#pic_center)
## 总结：
1. 手动脱壳时时刻关注esp寄存器，来找到正真程序的入口。




